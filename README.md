# Преобразование арифметического выражения в постфиксную форму
<nav class="toc">
  <h2>Содержание:</h2>
  <ol>
    <li><a href="#1">Постановка задачи</a>
    <li><a href="#2">Руководство пользователя</a>
    <li><a href="#3">Руководство программиста</a>
      <ul>
        <li><a href="#3.1">Структура проекта</a>
        <li><a href="#3.2">Структура программы</a>
        <li><a href="#3.3">Структуры данных</a>
          <ul>
            <li><a href="#3.3.1">Список</a>
            <li><a href="#3.3.2">Стек</a>
          </ul>
        <li><a href="#3.4">Описание алгоритмов</a>
          <ul>
            <li><a href="#3.4.1">Алгоритм преобразования арифметического выражения</a>
            <li><a href="#3.4.2">Алгоритм подсчета арифметического выражения</a>
          </ul>
      </ul>
    <li><a href="#4">Заключение</a>
    <li><a href="#5">Литература</a>
  </ol>
</nav>


<h2 id="1">Постановка задачи</h2>
Цель лабораторной работы : 
<ol>
  <li>Реализовать структуру данных Список.</li>
  <li>На динамической структуре данных Список реализовать сруктуру данных Стек.</li>
  <li>Тестировать реализованные структуры.</li>
  <li>Разработать реализацию алгоритма, преобразующего арифметическое выражение из инфиксной формы в постфиксную.</li>
  <li>Написать консольные приложения, демонстрирующие работу алгоритмов.</li>
  <li>Все действия над проектом должны отображаться в репозитории на сайте Github.com</li>
</ol>

<h2 id="2">Руководство пользователя</h2>
<h3> Запуск программы </h3>
Консольное приложение преднозначено для обраюотки символьной строки, представляющей собой арифметическое выражение, а именно преобразования ее из изначальной (инфиксной) формы записи в обратную (постфиксную), а так же вычисления данного арифметического выражения.
<h3></h3>
Для запуска программы необходимо открыть исполняемый файл sample_postfix.exe и следовать инструкциям.
<h3>Ввод данных</h3>
<ol>
  <li><a>Введите арифметическое выражение.</a>
    <ul>
      <li>Операции: +, -, *, /.</li>
      <li>Операнды: заглавные и строчные буквы латинского алфавита.</li>
    </ul>
  <li><a>Для продолжения нажмите Entr.</a>
    <ul>
      <li>На экран будут выведены:</li> 
      <li>String -> ВАШЕ ВЫРАЖЕНИЕ</li>
      <li>Postfix form -> ВАШЕ ВЫРАЖЕНИЕ В ПОСТФИКСНОЙ ФОРМЕ</li>
    </ul>
  <li><a>Далее введите значения соответствующих символов.</a>
  <li><a>Теперь, когда значения всех операндов введены, на экран будет выведен результат вычисления Result: РЕЗУЛЬТАТ.</a>
</ol>

<h2 id="3">Руководство программиста</h2>
<h3 id="3.1">Структура проекта</h3>
<ul>
  <li>gtest - библиотека GoogleTest;
  <li>src - директория для размещения файлов исходного кода;
  <li>samples - директория для размещения исходных кодов приложений;
  <li>include - директория для размещения заголовочных файлов;
  <li>test - директория для размещения тестов;
  <li>sln - директория с файлами решений и проектов для Visual Studio 2010;
  <li>README.md — отчет о лабораторной работе;
  <li>Служебные файлы:
    <ul>
      <li>.gitignore - перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий;
    </ul>
</ul>

<h3 id="3.2">Структура программы</h3>
Программа состоит из 6 проектов:
<ul>
  <li><a>gtest - фреймворк Google Test;</a>
  <li><a>postfix_lib - статическая библиотека, которая содержит объявление и реализацию шаблонных классов: Node, List, Stack, Postfix</a>
    <ul>
      <li>Node - описывает узел списка. Класс Node содержит два поля: ключ и указатель на следующий узел;
      <li>Lisi - класс Список, агрегирующий в себе  класс Node.
      <li>Stack - класс Стек, агрегирующий в себе класс List.
      <li>Postfix - класс для обработки арифметического выражения. Содержит два метода:
        <ul>
          <li>PostfixString - метод для перевода выражения из инфиксной формы записи в постфиксную
          <li>Calculator - метод для вычисления значения выражения
        </ul>
    </ul>
  <li><a></a>sample_list - консольное приложение для демонстрации работы методов класса List;
  <li><a></a>sample_stack - консольное приложение для демонстрации работы методов класса Stack;
  <li><a></a>sample_postfix — консольное приложение для визуализации перевода принимаемого выражения в постфиксную форму записи и подсчета значения этого выражения;
  <li><a></a>test - консольное приложение для проверки правильности реализации классов List и Stack;
</ul>
<h3 id="3.3">Структуры данных<h3>
<h4 id="3.3.1">Список</h4>
<h3></h3>
Линейный односвязный список - динамическая структура данных, хранящая однотипные элементы, связанные указателями. Каждое звено списка содержит два поля: ключ (key) и указатель на следующее звено (Next). Указатель на список - это указатель на первое звено списка (First). Указатель равный NULL - говорит об окончании списка.
<h3></h3>
Представлен в виде шаблонного класса List  и содержит следующие методв:
<ol>
  <li><a>List() - конструктор по умолчанию</a>
  <li><a>List(const List<ValType>&) - конструктор копирования</a>
  <li><a>~List() - деструктор</a>
  <li><a>PushStart - втавка в начало списка</a>
  <li><a>PushEnd - вставка в конец спмска</a>
  <li><a>PushAfter - вставка после элемента с заданым ключом</a>
  <li><a>PushBefore - вставка перед элементом с заданым ключом</a>
  <li><a>Search - поиск элемента с заданым ключом</a>
  <li><a>GetFirst - доступ к первому значению списка</a>
  <li><a>Remove - удаление элемента с заданым ключом</a>
  <li><a>Print - печать списка</a>
  <li><a>operator== - перегрузка операции сравнения на равенство списков</a>
  <li><a>operator!= - перегрузка операции спавнения на неравенство списков</a>
</ol>
<h4 id="3.3.2">Стек</h4>
<h3></h3>
Стек - Динамическая структура данных, представляющая собой набор однотипных элементов и работающая по принципу "последний вошел - первый вышел".
<h3></h3>
Представлен в виде шаблонного класса Stack, реализованного на базе линейного односвязного списка. Содержит следующие методы:
<ol>
  <li><a>Stack() - конструктор по умолчанию</a>
  <li><a>Stack(const Stack<ValType>&) - конструктор копирования</a>
  <li><a>~Stack() - деструктор</a>
  <li><a>IsFull - проверка на полноту</a>
  <li><a>IsEmpty - проверка на полноту</a>
  <li><a>Push - вставить элемент</a>
  <li><a>Pop - извлеч элемент</a>
  <li><a>GetValue - доступ к "голове" стека</a>
  <li><a>Print - печать элементов стека</a>
  <li><a>operator== - перегрузка операции сравнения на равенство</a>
  <li><a>operator!= - перегрузка операции спавнения на неравенство</a>
</ol>
<h3 id="3.4">Описание алгоритмов</h3>
<h4 id="3.4.1">Алгоритм преобразования арифметического выражения</h4>
<ol>
  <li><a></a>Стоит отметить, что стек операторов и стек операндов являются полями класса Postfix, т.е. внутри метода их создавать не нужно;
  <li><a></a>Создается ассоциативный массив priority в котором каждой операции присваивается приоритет в виде чисел типа int:
    <ul>
      <li>Приоритет операций '*' и '/' равен 3;
      <li>Приоритет операций '+' и '-' равен 2; 
      <li>Приоритет операций '(' и ')' равен 1;
      <li>Приоритет '=' равен 0;
    </ul>
  <li><a></a>Создается переменная типа char - в нее будет присваиваться элемент строки.
  <li><a></a>В цикле проходим по исходной строке str, проверяя каждый элемент
    <ul>
      <li>если элемент - это пробел, то его просто игнорируем
      <li>усли элемент - операция, то:
        <ul>
          <li>если приоритет элемента равен 1, то это либо '(' - тогда ее просто записываем в стек операторов operators, либо это ')', тогда в стеке операторов operators извлекаем и записываем в стек операндов arguments все элементы до '(', после чего извлекаем из стека операторов operators '(' - эта скобка нам больше не понадобится;
          <li>если же приоритет операции не равен 1, то в случае пустоты стека операторов operators елемент просто записывается в этот стек, если же стек не  пуст, то сравниваем приоритет операции, находящейся в "голове" стека, и приоритет входной операции. Если приоритет входной операции больше, то записываем ее в стек операторов operators , если меньше или равен, то будем извлекать и записывать в стек операндов arguments элементы стека операторов operators до тех пор, пока приоритет операции, стоящей в "голове" стека не станет больше приоритета входной операции, а затем запишем входную операцию в стек операндов arguments;
        </ul>
      <li>в противном случае, т.е. если елемент строки является операндом, записываем его в стек операндов arguments;
    </ul>
  <li><a>После завершения цикла извлекаем элементы из стека операторов и вставляем их в стек операндов до тех пор, пока стек операндов не опустеет.</a>
  <li><a>Проверяем стек операндов на пустоту. Там должны находится все значения, которые войдут в результирующую строку, поэтому если он пуст, то кидаем ошибку об отсутствии данных "Error : No data."</a>
  <li><a>В результате мы имеем в стеке операндов нашу строку в постфиксной форме, но задом на перед, поэтому мы извлекаем из стека операндов и записываем в стек оперераторов все элементы, тем самым получая в стеке операторов строку в постфиксном виде.</a>
  <li><a>В конце создаем пустую строку string_result и присваиваем в нее поочередно все элементы из стека операторов, после чего возвращаем эту строку как результат.</a>
</ol>
<h4 id="3.4.2">Алгоритм подсчета арифметического выражения</h4>
<ol>
  <li><a>Проверяется входящая строка на пустоту, если строка пустая, то кидается ошибка б отсутствии выражения "Error : The string is empty."</a>
  <li><a>Создаем переменную для хранения правого операнда RightOperand и переменную для хранения левого операнда LeftOperand типа ResType (тип, соответствующий типу операндов), переменную elem для хранения текущего элемента строки, переменную res под результат вычисления и стек Result для хранения операндов.</a>
  <li><a>Создается ассоциативный массив value.</a>
  <li><a>В цикле идем по строке (отметим, что на вход принята строка в постфиксной форме) и проверяем каждый элемент:</a>
    <ul>
      <li>если елемент - это операнд, то в массиве value ему присваисвается значение, т.е. теперь элемент типа char имеет свое численное значение, а затем записываем это численное значение в стек Result;
      <li>если же елемент - это операция, то извлекаем из стека Result сначала правый операнд и присваиваем его в переменную RightOperand, а затем левый операнд и присваиваеи его, соответственно, в переменную LeftOperand. Теперь с помощью оператора switch определяется что за операция пришла на вход и, соответственно, выполняется действие (LeftOperand <операция> RightOperand) и резальтат записывается в стек Result;
    </ul>
  <li><a>В результате в стеке Result должен остаться только один элемент, который мы извлекаем, записываем в переменную res и возвращаем в качестве ответа. Если же после извлечения елемента из стека Result стек не опустел, то кидается ошибка о некорректности введенных данных "Error : Incorrect expression."</a>
</ol>
<h2 id="4">Заключение</h2>
В ходе лабораторной работы были реализованы структуры данных Узел, Стек и Список с помощью шаблонных классов, а так же алгоритм, преобразуюий входную строку, являющую собой арифметическое выражение, из инфиксной формы записи  в постфиксную и реализующий последующее вычисление данного выражения. Были написаны тесты, проверяющие корректность реализации классов, а так же приложения, демонстрирующие работу каждого метода этих классов. Написано приложение, демонстрирующее перевод арифметического выражения из инфиксной формы записи в постфиксную и вычисления переведенного выражения.Все работы над проектом отображались в репозитории на сайте github.com, что не только визуализировало работу над проектом, но и позволяло при необходимости востановить нужные данные .
<h2 id="5">Литература</h2>
Шилдт, Герберт Полный справочник по C++, 4-е издание. : Пер. с англ. : -M. : Издательский дом "Вильямс" , 2004.-800 с.
